/* * * Zinitix zt7548 touchscreen driver * * Copyright (C) 2013 Samsung Electronics Co.Ltd * * This software is licensed under the terms of the GNU General Public * License version 2, as published by the Free Software Foundation, and * may be copied, distributed, and modified under those terms. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the * GNU General Public License for more details. * */#include <linux/pinctrl/consumer.h>#include "zt7548_ts.h"u32 BUTTON_MAPPING_KEY[MAX_SUPPORTED_BUTTON_NUM] = {KEY_BACK, KEY_BACK};/* Goya model used below feature */#ifdef CONFIG_LCD_ESD_RECOVERY_BY_TSPextern void ESD_recover(void);static int m_tsp_burst_mode;#endifstatic int cal_mode;static int get_boot_mode(char *str){	get_option(&str, &cal_mode);	printk(KERN_DEBUG "get_boot_mode, uart_mode : %d\n", cal_mode);	return 1;}__setup("calmode=", get_boot_mode);static void zinitix_delay(unsigned int ms){	if (ms <= 20)		usleep_range(ms * 1000, ms * 1000);	else		msleep(ms);}static s32 read_data(struct i2c_client *client, u16 reg, u8 *values, u16 length){	s32 ret;	int count = 0;retry_send:	ret = i2c_master_send(client, (u8 *)&reg, 2);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to send. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry_send;		return ret;	}	usleep_range(DELAY_FOR_TRANSCATION, DELAY_FOR_TRANSCATION);	count = 0;retry_read:	ret = i2c_master_recv(client, values, length);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to recv. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry_read;		return ret;	}	usleep_range(DELAY_FOR_POST_TRANSCATION, DELAY_FOR_POST_TRANSCATION);	return length;}#if TOUCH_POINT_MODEstatic s32 read_data_only(struct i2c_client *client, u8 *values, u16 length){	s32 ret;	int count = 0;retry:	ret = i2c_master_recv(client, values, length);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to recv. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry;		return ret;	}	usleep_range(DELAY_FOR_TRANSCATION, DELAY_FOR_TRANSCATION);	return length;}#endifstatic inline s32 write_data(struct i2c_client *client, u16 reg, u8 *values, u16 length){	s32 ret;	int count = 0;	u8 pkt[10];	pkt[0] = (reg) & 0xff;	pkt[1] = (reg >> 8) & 0xff;	memcpy((u8 *)&pkt[2], values, length);retry:	ret = i2c_master_send(client , pkt , length + 2);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to send. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry;		return ret;	}	usleep_range(DELAY_FOR_POST_TRANSCATION, DELAY_FOR_POST_TRANSCATION);	return length;}static s32 write_reg(struct i2c_client *client, u16 reg, u16 value){	if (write_data(client, reg, (u8 *)&value, 2) < 0)		return I2C_FAIL;	return I2C_SUCCESS;}static s32 write_cmd(struct i2c_client *client, u16 reg){	s32 ret;	int count = 0;retry:	ret = i2c_master_send(client , (u8 *)&reg , 2);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to send. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry;		return ret;	}	usleep_range(DELAY_FOR_POST_TRANSCATION, DELAY_FOR_POST_TRANSCATION);	return I2C_SUCCESS;}static inline s32 read_raw_data(struct i2c_client *client, u16 reg, u8 *values, u16 length){	s32 ret;	int count = 0;retry_send:	/* select register */	ret = i2c_master_send(client , (u8 *)&reg , 2);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to send. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry_send;		return ret;	}	/* for setup tx transaction. */	usleep_range(200, 200);	count = 0;retry_read:	ret = i2c_master_recv(client, values, length);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to recv. ret:%d, try:%d\n",							__func__, ret, count + 1);		zinitix_delay(1);		if (++count < I2C_RETRY_TIMES)			goto retry_read;		return ret;	}	usleep_range(DELAY_FOR_POST_TRANSCATION, DELAY_FOR_POST_TRANSCATION);	return length;}static inline s32 read_firmware_data(struct i2c_client *client, u16 addr, u8 *values, u16 length){	s32 ret;	ret = i2c_master_send(client , (u8 *)&addr , 2);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to send. ret:%d\n", __func__, ret);		return ret;	}	/* for setup tx transaction. */	zinitix_delay(1);	ret = i2c_master_recv(client , values , length);	if (ret < 0) {		dev_err(&client->dev, "%s: failed to recv. ret:%d\n", __func__, ret);		return ret;	}	usleep_range(DELAY_FOR_POST_TRANSCATION, DELAY_FOR_POST_TRANSCATION);	return length;}static void zt7548_set_optional_mode(struct zt7548_ts_info *info, bool force){	if (!info->device_enabled)		return;	if (m_prev_optional_mode == m_optional_mode && !force)		return;	if (write_reg(info->client, ZT7548_OPTIONAL_SETTING, m_optional_mode) == I2C_SUCCESS) {		m_prev_optional_mode = m_optional_mode;		dev_info(&misc_info->client->dev, "%s: 0x%04x\n",						__func__, m_optional_mode);	}}static void zt7548_set_ta_status(struct zt7548_ts_info *info){	if (ta_connected)		zinitix_bit_set(m_optional_mode, DEF_OPTIONAL_MODE_USB_DETECT_BIT);	else		zinitix_bit_clr(m_optional_mode, DEF_OPTIONAL_MODE_USB_DETECT_BIT);	zt7548_set_optional_mode(info, false);}#ifdef USE_TSP_TA_CALLBACKSstatic void zt7548_ts_charger_status_cb(struct tsp_callbacks *cb, int status){	dev_info(&misc_info->client->dev, "%s: TA %s\n", __func__,			status ? "connected" : "disconnected");	status = (status != POWER_SUPPLY_TYPE_UNKNOWN);	if (status)		ta_connected = true;	else		ta_connected = false;	zt7548_set_ta_status(misc_info);}static void zt7548_register_callback(struct tsp_callbacks *cb){	charger_callbacks = cb;	pr_info("%s\n", __func__);}#endif#define I2C_BUFFER_SIZE 64static bool ts_get_raw_data(struct zt7548_ts_info *info){	struct i2c_client *client = info->client;	u32 total_node = info->cap_info.total_node_num;	int sz;	u16 temp_sz;	int i;	if (down_trylock(&info->raw_data_lock)) {		dev_err(&client->dev, "Failed to occupy sema\n");		info->touch_info.status = 0;		return true;	}	sz = total_node * 2 + sizeof(struct point_info);	for (i = 0; sz > 0; i++) {		temp_sz = I2C_BUFFER_SIZE;		if (sz < I2C_BUFFER_SIZE)			temp_sz = sz;		if (read_raw_data(info->client, ZT7548_RAWDATA_REG + i,			(char *)((u8*)(info->cur_data)+ (i * I2C_BUFFER_SIZE)), temp_sz) < 0) {			dev_err(&client->dev, "Failed to read raw data\n");			up(&info->raw_data_lock);			return false;		}		sz -= I2C_BUFFER_SIZE;	}	info->update = 1;	memcpy((u8 *)(&info->touch_info),			(u8 *)&info->cur_data[total_node], sizeof(struct point_info));	up(&info->raw_data_lock);	return true;}#if (TOUCH_POINT_MODE == 0)#endifstatic bool ts_read_coord(struct zt7548_ts_info *info){	struct i2c_client *client = info->client;#ifdef CONFIG_LCD_ESD_RECOVERY_BY_TSP	u16 status;#endif#if TOUCH_POINT_MODE	int i;#endif	/* for  Debugging Tool */	if (info->touch_mode != TOUCH_POINT_MODE) {		if (info->update == 0) {			if (!ts_get_raw_data(info))				return false;		} else			info->touch_info.status = 0;		dev_err(&client->dev, "status = 0x%04X\n", info->touch_info.status);		goto out;	}#if TOUCH_POINT_MODE	memset(&info->touch_info, 0x0, sizeof(struct point_info));	if (read_data_only(info->client, (u8 *)(&info->touch_info), 10) < 0) {		dev_err(&client->dev, "error read point info using i2c.-\r\n");		return false;	}	if (info->touch_info.event_flag == 0 || info->touch_info.status == 0) {		zt7548_set_optional_mode(info, false);#ifdef CONFIG_LCD_ESD_RECOVERY_BY_TSP		if (read_data(info->client, ZT7548_OPTIONAL_SETTING, (u8 *)&status, 2) < 0) {			dev_err(&client->dev, "error read noise mode.-\n");			return false;		}		m_tsp_burst_mode = zinitix_bit_test(status, 10) ? 1 : 0;		if (m_tsp_burst_mode) {			dev_info(&client->dev, "Enter LCD ESD Recover\n");			ESD_recover();		}#endif		write_cmd(info->client, ZT7548_CLEAR_INT_STATUS_CMD);		return true;	}	for (i = 1; i < info->cap_info.multi_fingers; i++) {		if (zinitix_bit_test(info->touch_info.event_flag, i)) {			usleep_range(20, 20);			if (read_data(info->client, ZT7548_POINT_STATUS_REG + 2 + (i * 4),				(u8 *)(&info->touch_info.coord[i]), sizeof(struct coord)) < 0) {				dev_err(&client->dev, "error read point info\n");				return false;			}		}	}#else   /* TOUCH_POINT_MODE */	if (read_data(info->client, ZT7548_POINT_STATUS_REG,			(u8 *)(&info->touch_info), sizeof(struct point_info)) < 0) {		dev_err(&client->dev, "Failed to read point info\n");		return false;	}#endif	/* TOUCH_POINT_MODE */	zt7548_set_optional_mode(info, false);#ifdef CONFIG_LCD_ESD_RECOVERY_BY_TSP	if (read_data(info->client, ZT7548_OPTIONAL_SETTING, (u8 *)&status, 2) < 0) {		dev_err(&client->dev, "error read noise mode\n");		return false;	}#endifout:	if (zinitix_bit_test(info->touch_info.status, BIT_MUST_ZERO)) {		dev_err(&client->dev, "Invalid must zero bit(%04x)\n", info->touch_info.status);		return false;	}	write_cmd(info->client, ZT7548_CLEAR_INT_STATUS_CMD);	return true;}#if ESD_TIMER_INTERVALstatic void esd_timeout_handler(unsigned long data){	struct zt7548_ts_info *info = (struct zt7548_ts_info *)data;	info->p_esd_timeout_tmr = NULL;	queue_work(esd_tmr_workqueue, &info->tmr_work);}static void esd_timer_start(u16 sec, struct zt7548_ts_info *info){	unsigned long flags;	spin_lock_irqsave(&info->lock, flags);	if (info->p_esd_timeout_tmr)#ifdef CONFIG_SMP		del_singleshot_timer_sync(info->p_esd_timeout_tmr);#else		del_timer(info->p_esd_timeout_tmr);#endif	info->p_esd_timeout_tmr = NULL;	init_timer(&(info->esd_timeout_tmr));	info->esd_timeout_tmr.data = (unsigned long)(info);	info->esd_timeout_tmr.function = esd_timeout_handler;	info->esd_timeout_tmr.expires = jiffies + (HZ * sec);	info->p_esd_timeout_tmr = &info->esd_timeout_tmr;	add_timer(&info->esd_timeout_tmr);	spin_unlock_irqrestore(&info->lock, flags);}static void esd_timer_stop(struct zt7548_ts_info *info){	unsigned long flags;	spin_lock_irqsave(&info->lock, flags);	if (info->p_esd_timeout_tmr)#ifdef CONFIG_SMP		del_singleshot_timer_sync(info->p_esd_timeout_tmr);#else		del_timer(info->p_esd_timeout_tmr);#endif	info->p_esd_timeout_tmr = NULL;	spin_unlock_irqrestore(&info->lock, flags);}static void esd_timer_init(struct zt7548_ts_info *info){	unsigned long flags;	spin_lock_irqsave(&info->lock, flags);	init_timer(&(info->esd_timeout_tmr));	info->esd_timeout_tmr.data = (unsigned long)(info);	info->esd_timeout_tmr.function = esd_timeout_handler;	info->p_esd_timeout_tmr = NULL;	spin_unlock_irqrestore(&info->lock, flags);}static void ts_tmr_work(struct work_struct *work){	struct zt7548_ts_info *info =				container_of(work, struct zt7548_ts_info, tmr_work);	struct i2c_client *client = info->client;printk("ts_tmr_work\n");	if (down_trylock(&info->work_lock)) {		dev_err(&client->dev, "%s: Failed to occupy work lock\n", __func__);		esd_timer_start(CHECK_ESD_TIMER, info);		return;	}	if (info->work_state != NOTHING) {		dev_info(&client->dev, "%s: Other process occupied\n", __func__);		up(&info->work_lock);		return;	}	info->work_state = ESD_TIMER;	disable_irq(info->irq);	zt7548_power_control(info, POWER_OFF);	zt7548_power_control(info, POWER_ON_SEQUENCE);	clear_report_data(info);	if (!mini_init_touch(info))		goto fail_time_out_init;	info->work_state = NOTHING;	enable_irq(info->irq);	up(&info->work_lock);	return;fail_time_out_init:	dev_err(&client->dev, "%s: Failed to restart\n", __func__);	esd_timer_start(CHECK_ESD_TIMER, info);	info->work_state = NOTHING;	enable_irq(info->irq);	up(&info->work_lock);	return;}#endifstatic bool zt7548_power_sequence(struct zt7548_ts_info *info){	struct i2c_client *client = info->client;	int retry = 0;	u16 chip_code;retry_power_sequence:	if (write_reg(client, 0xc000, 0x0001) != I2C_SUCCESS) {		dev_err(&client->dev, "Failed to send power sequence(vendor cmd enable)\n");		goto fail_power_sequence;	}	usleep_range(10, 10);	if (read_data(client, 0xcc00, (u8 *)&chip_code, 2) < 0) {		dev_err(&client->dev, "Failed to read chip code\n");		goto fail_power_sequence;	}	dev_dbg(&client->dev, "%s: chip code = 0x%x\n", __func__, chip_code);	usleep_range(10, 10);	if (write_cmd(client, 0xc004) != I2C_SUCCESS) {		dev_err(&client->dev, "Failed to send power sequence(intn clear)\n");		goto fail_power_sequence;	}	usleep_range(10, 10);	if (write_reg(client, 0xc002, 0x0001) != I2C_SUCCESS) {		dev_err(&client->dev, "Failed to send power sequence(nvm init)\n");		goto fail_power_sequence;	}	zinitix_delay(2);	if (write_reg(client, 0xc001, 0x0001) != I2C_SUCCESS) {		dev_err(&client->dev, "Failed to send power sequence(program start)\n");		goto fail_power_sequence;	}	zinitix_delay(FIRMWARE_ON_DELAY);	/* wait for checksum cal */	return true;fail_power_sequence:	if (retry++ < 3) {		zinitix_delay(CHIP_ON_DELAY);		dev_info(&client->dev, "retry = %d\n", retry);		goto retry_power_sequence;	}	dev_err(&client->dev, "Failed to send power sequence\n");	return false;}static int zt7548_power(struct i2c_client *client, int on){	return 0;}static bool zt7548_power_control(struct zt7548_ts_info *info, u8 ctl){	int ret;	ret = info->pdata->tsp_power(info->client, ctl);	if (ret)		return false;	if (ctl == POWER_ON_SEQUENCE) {		return zt7548_power_sequence(info);	}	return true;}#define TC_SECTOR_SZ		8static bool ts_hw_calibration(struct zt7548_ts_info *info){	struct i2c_client *client = info->client;	u16 chip_eeprom_info;	int time_out = 0;	dev_info(&client->dev, "%s +++\n", __func__);	if (write_reg(client, ZT7548_TOUCH_MODE, 0x07) != I2C_SUCCESS)		return false;	zinitix_delay(10);	write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);	zinitix_delay(10);	write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);	zinitix_delay(50);	write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);	zinitix_delay(10);	if (write_cmd(client, ZT7548_CALIBRATE_CMD) != I2C_SUCCESS)		return false;	if (write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD) != I2C_SUCCESS)		return false;	zinitix_delay(10);	write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);	/* wait for h/w calibration*/	do {		zinitix_delay(500);		write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);		if (read_data(client, ZT7548_EEPROM_INFO_REG, (u8 *)&chip_eeprom_info, 2) < 0)			return false;		dev_dbg(&client->dev, "touch eeprom info = 0x%04X\n", chip_eeprom_info);		if (!zinitix_bit_test(chip_eeprom_info, 0))			break;		if (time_out++ > 10) {			dev_err(&client->dev, "h/w calibration timeout.\n");			break;		}		if (time_out++ == 4) {			write_cmd(client, ZT7548_CALIBRATE_CMD);			zinitix_delay(10);			write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);			dev_err(&client->dev, "h/w calibration retry timeout.\n");		}	} while (true);	if (write_reg(client, ZT7548_TOUCH_MODE, TOUCH_POINT_MODE) != I2C_SUCCESS)		return false;	if (info->cap_info.ic_int_mask) {		if (write_reg(client, ZT7548_INT_ENABLE_FLAG,					info->cap_info.ic_int_mask) != I2C_SUCCESS)			return false;	}	usleep_range(100, 100);	if (write_cmd(client, ZT7548_SAVE_CALIBRATION_CMD) != I2C_SUCCESS)		return false;	zinitix_delay(1000);	dev_info(&client->dev, "%s ---\n", __func__);	return true;}static bool init_touch(struct zt7548_ts_info *info, bool fw_skip){	struct zt7548_ts_dt_data *pdata = info->pdata;	struct i2c_client *client = info->client;	struct capa_info *cap = &(info->cap_info);	u16 reg_val;	int i;	u16 chip_eeprom_info;	u16 chip_code = 0;	int retry_cnt = 0;	info->ref_scale_factor = TSP_INIT_TEST_RATIO;retry_init:	for (i = 0; i < INIT_RETRY_CNT; i++) {		if (read_data(client, ZT7548_EEPROM_INFO_REG,						(u8 *)&chip_eeprom_info, 2) < 0) {			dev_err(&client->dev, "Failed to read eeprom info(%d)\n", i);			zinitix_delay(10);			continue;		} else			break;	}	if (i == INIT_RETRY_CNT)		goto fail_init;	if (write_cmd(client, ZT7548_SWRESET_CMD) != I2C_SUCCESS) {		dev_err(&client->dev, "Failed to write reset command\n");		goto fail_init;	}	cap->button_num = SUPPORTED_BUTTON_NUM;	reg_val = 0;	zinitix_bit_set(reg_val, BIT_PT_CNT_CHANGE);	zinitix_bit_set(reg_val, BIT_DOWN);	zinitix_bit_set(reg_val, BIT_MOVE);	zinitix_bit_set(reg_val, BIT_UP);	if (cap->button_num > 0)		zinitix_bit_set(reg_val, BIT_ICON_EVENT);#if SUPPORTED_PALM_TOUCH	zinitix_bit_set(reg_val, BIT_PALM);#endif	cap->ic_int_mask = reg_val;	if (write_reg(client, ZT7548_INT_ENABLE_FLAG, 0x0) != I2C_SUCCESS)		goto fail_init;	dev_dbg(&client->dev, "%s: Send reset command\n", __func__);	if (write_cmd(client, ZT7548_SWRESET_CMD) != I2C_SUCCESS)		goto fail_init;	/* get chip information */	if (read_data(client, ZT7548_VENDOR_ID, (u8 *)&cap->vendor_id, 2) < 0) {		dev_err(&client->dev, "failed to read vendor id\n");		goto fail_init;	}	if (read_data(client, ZT7548_CHIP_REVISION, (u8 *)&cap->ic_revision, 2) < 0) {		dev_err(&client->dev, "failed to read chip revision\n");		goto fail_init;	}	if (read_data(client, 0xcc00, (u8 *)&chip_code, 2) < 0) {		chip_code = 0;		dev_err(&client->dev, "Failed to read chip code\n");		goto fail_init;	}	info->chip_code = chip_code;	dev_info(&client->dev, "%s: chip code = 0x%X\n", __func__, info->chip_code);	if (info->chip_code == ZT7548_IC_CHIP_CODE) {		cap->ic_fw_size = 48 * 1024;	} else if (info->chip_code == ZT7538_IC_CHIP_CODE) {		cap->ic_fw_size = 44 * 1024;	} else {		chip_code = 0;		dev_err(&client->dev, "%s: Unknown IC!! Cannot set ic_fw_size!!\n", __func__);		goto fail_init;	}	if (read_data(client, ZT7548_HW_ID, (u8 *)&cap->hw_id, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_THRESHOLD, (u8 *)&cap->threshold, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_BUTTON_SENSITIVITY, (u8 *)&cap->key_threshold, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_DUMMY_BUTTON_SENSITIVITY, (u8 *)&cap->dummy_threshold, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_TOTAL_NUMBER_OF_X, (u8 *)&cap->x_node_num, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_TOTAL_NUMBER_OF_Y, (u8 *)&cap->y_node_num, 2) < 0)		goto fail_init;	cap->total_node_num = cap->x_node_num * cap->y_node_num;	if (read_data(client, ZT7548_DND_CP_CTRL_L, (u8 *)&cap->cp_ctrl_l, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_DND_V_FORCE, (u8 *)&cap->v_force, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_DND_AMP_V_SEL, (u8 *)&cap->amp_v_sel, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_DND_N_COUNT, (u8 *)&cap->N_cnt, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_DND_U_COUNT, (u8 *)&cap->u_cnt, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_AFE_FREQUENCY, (u8 *)&cap->afe_frequency, 2) < 0)		goto fail_init;	/* get chip firmware version */	if (read_data(client, ZT7548_FIRMWARE_VERSION, (u8 *)&cap->fw_version, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_MINOR_FW_VERSION, (u8 *)&cap->fw_minor_version, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_DATA_VERSION_REG, (u8 *)&cap->reg_data_version, 2) < 0)		goto fail_init;	if (read_data(client, ZT7548_EEPROM_INFO_REG, (u8 *)&chip_eeprom_info, 2) < 0)		goto fail_init;	if (zinitix_bit_test(chip_eeprom_info, 0)) {		if (!ts_hw_calibration(info))			goto fail_init;		/* disable chip interrupt */		if (write_reg(client, ZT7548_INT_ENABLE_FLAG, 0) != I2C_SUCCESS)			goto fail_init;	}	if (write_reg(client, ZT75XX_RESOLUTION_EXPANDER, 4))  //resolution * 4		goto fail_init;	cap->MinX = (u32)0;	cap->MinY = (u32)0;	cap->MaxX = (u32)pdata->x_resolution;	cap->MaxY = (u32)pdata->y_resolution;	if (write_reg(client, ZT7548_BUTTON_SUPPORTED_NUM, (u16)cap->button_num) != I2C_SUCCESS)		goto fail_init;	if (write_reg(client, ZT7548_SUPPORTED_FINGER_NUM, (u16)MAX_SUPPORTED_FINGER_NUM) != I2C_SUCCESS)		goto fail_init;	cap->multi_fingers = MAX_SUPPORTED_FINGER_NUM;	cap->gesture_support = 0;	if (write_reg(client, ZT7548_INITIAL_TOUCH_MODE, TOUCH_POINT_MODE) != I2C_SUCCESS)		goto fail_init;	if (write_reg(client, ZT7548_TOUCH_MODE, info->touch_mode) != I2C_SUCCESS)		goto fail_init;	zt7548_set_ta_status(info);	zt7548_set_optional_mode(info, true);	if (write_reg(client, ZT7548_INT_ENABLE_FLAG, cap->ic_int_mask) != I2C_SUCCESS)		goto fail_init;	/* read garbage data */	for (i = 0; i < 10; i++) {		write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);		usleep_range(10, 10);	}	if (info->touch_mode != TOUCH_POINT_MODE) { /* Test Mode */		if (write_reg(client, ZT7548_DELAY_RAW_FOR_HOST,					RAWDATA_DELAY_FOR_HOST) != I2C_SUCCESS) {			dev_err(&client->dev, "%s: Failed to set DELAY_RAW_FOR_HOST\n", __func__);			goto fail_init;		}	}#if ESD_TIMER_INTERVAL	//if (write_reg(client, ZT7548_PERIODICAL_INTERRUPT_INTERVAL,	//			SCAN_RATE_HZ * ESD_TIMER_INTERVAL) != I2C_SUCCESS)	//	goto fail_init;	read_data(client, ZT7548_PERIODICAL_INTERRUPT_INTERVAL, (u8 *)&reg_val, 2);#endif	dev_info(&client->dev, "%s: initialize done!\n", __func__);	return true;fail_init:	printk("zt7548, fail_init\n");	if (cal_mode) {		dev_err(&client->dev, "didn't update TSP F/W!! in CAL MODE\n");		goto retry_fail_init;	}	if (++retry_cnt <= INIT_RETRY_CNT) {		zt7548_power_control(info, POWER_OFF);		zt7548_power_control(info, POWER_ON_SEQUENCE);		goto retry_init;	} else if (retry_cnt == INIT_RETRY_CNT + 1) {		if (chip_code == 0) {#if defined(CONFIG_TOUCHSCREEN_ZT7548_TS)			cap->ic_fw_size = 48 * 1024;#elif defined(CONFIG_TOUCHSCREEN_ZT7538_TS)			cap->ic_fw_size = 44 * 1024;#else			dev_err(&client->dev, "%s: Unknown IC!!\n", __func__);			goto retry_fail_init;#endif		}		zinitix_delay(100);		/* hw calibration and make checksum */		if (!ts_hw_calibration(info)) {			dev_err(&client->dev, "failed to initiallize\n");			goto retry_fail_init;		}		goto retry_init;	}retry_fail_init:	return false;}static bool mini_init_touch(struct zt7548_ts_info *info){	struct i2c_client *client = info->client;	int i;	info->ref_scale_factor = TSP_INIT_TEST_RATIO;	if (write_cmd(client, ZT7548_SWRESET_CMD) != I2C_SUCCESS) {		dev_info(&client->dev, "Failed to write reset command\n");		goto fail_mini_init;	}	if (write_reg(client, ZT75XX_RESOLUTION_EXPANDER, 4)) //resolution * 4		goto fail_mini_init;	if (write_reg(client, ZT7548_BUTTON_SUPPORTED_NUM, (u16)info->cap_info.button_num) != I2C_SUCCESS)		goto fail_mini_init;	if (write_reg(client, ZT7548_SUPPORTED_FINGER_NUM, (u16)MAX_SUPPORTED_FINGER_NUM) != I2C_SUCCESS)		goto fail_mini_init;	if (write_reg(client, ZT7548_INITIAL_TOUCH_MODE, TOUCH_POINT_MODE) != I2C_SUCCESS)		goto fail_mini_init;	if (write_reg(client, ZT7548_TOUCH_MODE, info->touch_mode) != I2C_SUCCESS)		goto fail_mini_init;	zt7548_set_ta_status(info);	zt7548_set_optional_mode(info, true);	/* soft calibration */	if (write_cmd(client, ZT7548_CALIBRATE_CMD) != I2C_SUCCESS)		goto fail_mini_init;	if (write_reg(client, ZT7548_INT_ENABLE_FLAG, info->cap_info.ic_int_mask) != I2C_SUCCESS)		goto fail_mini_init;	/* read garbage data */	for (i = 0; i < 10; i++) {		write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);		usleep_range(10, 10);	}	if (info->touch_mode != TOUCH_POINT_MODE) {		if (write_reg(client, ZT7548_DELAY_RAW_FOR_HOST,					RAWDATA_DELAY_FOR_HOST) != I2C_SUCCESS){			dev_err(&client->dev, "Failed to set ZT7548_DELAY_RAW_FOR_HOST\n");			goto fail_mini_init;		}	}#if ESD_TIMER_INTERVAL	//if (write_reg(client, ZT7548_PERIODICAL_INTERRUPT_INTERVAL,	//		SCAN_RATE_HZ * ESD_TIMER_INTERVAL) != I2C_SUCCESS)	//	goto fail_mini_init;	esd_timer_start(CHECK_ESD_TIMER, info);#endif	dev_info(&client->dev, "Successfully mini initialized\r\n");	return true;fail_mini_init:	dev_err(&client->dev, "Failed to initialize mini init\n");	zt7548_power_control(info, POWER_OFF);	zt7548_power_control(info, POWER_ON_SEQUENCE);	if (!init_touch(info, false)) {		dev_err(&client->dev, "Failed to initialize\n");		return false;	}#if ESD_TIMER_INTERVAL	esd_timer_start(CHECK_ESD_TIMER, info);#endif	return true;}static void clear_report_data(struct zt7548_ts_info *info){	int i;	bool reported = false;	u8 sub_status;	for (i = 0; i < info->cap_info.button_num; i++) {		if (info->button[i] == ICON_BUTTON_DOWN) {			info->button[i] = ICON_BUTTON_UP;			input_report_key(info->input_dev, BUTTON_MAPPING_KEY[i], 0);#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)			dev_info(&info->client->dev, "key %d up\n", BUTTON_MAPPING_KEY[i]);#else			dev_info(&info->client->dev, "key up\n");#endif			reported = true;		}		input_report_key(info->input_dev, BTN_TOUCH, 0);	}	for (i = 0; i < info->cap_info.multi_fingers; i++) {		sub_status = info->reported_touch_info.coord[i].sub_status;		if (zinitix_bit_test(sub_status, SUB_BIT_EXIST)) {			dev_info(&info->client->dev, "[%d][R] M[%d] Ver[%02x] Mode[%02x]\n",					i, info->move_cnt[i],					info->cap_info.reg_data_version, m_optional_mode);			info->move_cnt[i] = 0;			input_mt_slot(info->input_dev, i);#ifdef REPORT_2D_Z			input_report_abs(info->input_dev, ABS_MT_PRESSURE, 0);#endif			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);			reported = true;		}		info->reported_touch_info.coord[i].sub_status = 0;		info->finger_cnt = 0;	}	if (reported)		input_sync(info->input_dev);	input_mt_slot(info->input_dev, 0);	input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);#ifdef CONFIG_INPUT_BOOSTER	if (info->booster && info->booster->dvfs_set)		info->booster->dvfs_set(info->booster, -1);#endif}static irqreturn_t zt7548_touch_work(int irq, void *data){	struct zt7548_ts_info *info = (struct zt7548_ts_info *)data;	struct zt7548_ts_dt_data *pdata = info->pdata;	struct i2c_client *client = info->client;	int i = 0;	u8 sub_status;	u8 prev_sub_status;	u32 x, y, maxX, maxY;	u32 w;	u32 tmp;#ifdef REPORT_2D_Z	u16 z = 0;	int ret = 0;#endif	u8 palm = 0;	if (gpio_get_value(info->pdata->gpio_int)) {		dev_err(&client->dev, "Invalid interrupt\n");		return IRQ_HANDLED;	}	if (down_trylock(&info->work_lock)) {		dev_err(&client->dev, "%s: Failed to occupy work lock\n", __func__);		write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);		return IRQ_HANDLED;	}#if ESD_TIMER_INTERVAL	esd_timer_stop(info);#endif	if (info->work_state != NOTHING) {		dev_err(&client->dev, "%s: Other process occupied\n", __func__);		usleep_range(DELAY_FOR_SIGNAL_DELAY, DELAY_FOR_SIGNAL_DELAY);		if (!gpio_get_value(info->pdata->gpio_int)) {			write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);			usleep_range(DELAY_FOR_SIGNAL_DELAY, DELAY_FOR_SIGNAL_DELAY);		}		goto out;	}	info->work_state = NORMAL;   	if (!ts_read_coord(info) || info->touch_info.status == 0xffff || info->touch_info.status == 0x1) {		dev_err(&client->dev, "Failed to read info coord\n");		zt7548_power_control(info, POWER_OFF);		zt7548_power_control(info, POWER_ON_SEQUENCE);		clear_report_data(info);		mini_init_touch(info);		goto out;	}	/* invalid : maybe periodical repeated int. */	if (info->touch_info.status == 0x0)		goto out;	if (zinitix_bit_test(info->touch_info.status, BIT_ICON_EVENT)) {		if (read_data(info->client, ZT7548_ICON_STATUS_REG,			(u8 *)(&info->icon_event_reg), 2) < 0) {			dev_err(&client->dev, "Failed to read button info\n");			write_cmd(client, ZT7548_CLEAR_INT_STATUS_CMD);			goto out;		}		for (i = 0; i < info->cap_info.button_num; i++) {			if (zinitix_bit_test(info->icon_event_reg, (BIT_O_ICON0_DOWN + i))) {				input_report_key(info->input_dev, BUTTON_MAPPING_KEY[i], 1);				if (info->button[i] != ICON_BUTTON_DOWN)#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)					dev_info(&client->dev, "key %d down\n", BUTTON_MAPPING_KEY[i]);#else					dev_info(&client->dev, "key down\n");#endif				info->button[i] = ICON_BUTTON_DOWN;			}		}		for (i = 0; i < info->cap_info.button_num; i++) {			if (zinitix_bit_test(info->icon_event_reg, (BIT_O_ICON0_UP + i))) {				info->button[i] = ICON_BUTTON_UP;				input_report_key(info->input_dev, BUTTON_MAPPING_KEY[i], 0);#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)				dev_info(&client->dev, "key %d up\n", BUTTON_MAPPING_KEY[i]);#else				dev_info(&client->dev, "key up\n");#endif			}		}	}#if SUPPORTED_PALM_TOUCH	if(zinitix_bit_test(info->touch_info.status, BIT_PALM)){        	dev_dbg(&client->dev, "palm report\n");		palm = 1;	}	if(zinitix_bit_test(info->touch_info.status, BIT_PALM_REJECT)){		dev_dbg(&client->dev, "palm reject\n");		palm = 2;	}#endif	for (i = 0; i < info->cap_info.multi_fingers; i++) {		sub_status = info->touch_info.coord[i].sub_status;		prev_sub_status = info->reported_touch_info.coord[i].sub_status;		if (zinitix_bit_test(sub_status, SUB_BIT_EXIST)) {			x = info->touch_info.coord[i].x;			y = info->touch_info.coord[i].y;			w = info->touch_info.coord[i].width;			 /* transformation from touch to screen orientation */			if (pdata->orientation & TOUCH_V_FLIP)				y = info->cap_info.MaxY + info->cap_info.MinY - y;			if (pdata->orientation & TOUCH_H_FLIP)				x = info->cap_info.MaxX + info->cap_info.MinX - x;				maxX = info->cap_info.MaxX;				maxY = info->cap_info.MaxY;				if (x > maxX || y > maxY) {#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)					dev_err(&client->dev,								"Invalid coord %d : x=%d, y=%d\n", i, x, y);#endif					continue;				}			if (pdata->orientation & TOUCH_XY_SWAP) {				zinitix_swap_v(x, y, tmp);				zinitix_swap_v(maxX, maxY, tmp);			}			info->touch_info.coord[i].x = x;			info->touch_info.coord[i].y = y;			if (zinitix_bit_test(sub_status, SUB_BIT_DOWN)) {				info->finger_cnt++;#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)				dev_info(&client->dev, "[%d][P] x = %d, y = %d,"						" w = %d, p = %d\n",i, x, y, w, palm);#else				dev_info(&client->dev,						"[%d][P] w = %d, p = %d\n", i, w, palm);#endif			} else if (zinitix_bit_test(sub_status, SUB_BIT_MOVE)) {				info->move_cnt[i]++;			}			if (w == 0)				w = 1;			input_mt_slot(info->input_dev, i);			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 1);#if SUPPORTED_PALM_TOUCH			if(palm == 0) {				if(w >= PALM_REPORT_WIDTH)				        w = PALM_REPORT_WIDTH - 10;				minor_w = w;			}			else if(palm == 1) {	//palm report				w = PALM_REPORT_WIDTH;				minor_w = PALM_REPORT_WIDTH/3;			} else if(palm == 2){	// palm reject				//x = y = 0;				w = PALM_REJECT_WIDTH;				minor_w = PALM_REJECT_WIDTH;			}			input_report_abs(info->input_dev, ABS_MT_TOUCH_MINOR, (u32)minor_w);			input_report_abs(info->input_dev, ABS_MT_CUSTOM, (palm > 0) ? 1 : 0);#endif			input_report_abs(info->input_dev, ABS_MT_TOUCH_MAJOR, (u32)w);#ifdef REPORT_2D_Z			ret = read_data(client, ZT7548_REAL_WIDTH + i, (u8*)&z, 2);			if (ret < 0)				dev_info(&client->dev, ": Failed to read %d's Real width %s\n", i, __func__);			if (z < 1) z = 1;			input_report_abs(info->input_dev, ABS_MT_PRESSURE, (u32)z);#endif			input_report_abs(info->input_dev, ABS_MT_WIDTH_MAJOR,								(u32)((palm == 1) ? (w - 40) : w));			input_report_abs(info->input_dev, ABS_MT_POSITION_X, x);			input_report_abs(info->input_dev, ABS_MT_POSITION_Y, y);			input_report_key(info->input_dev, BTN_TOUCH, 1);		} else if (zinitix_bit_test(sub_status, SUB_BIT_UP) ||			zinitix_bit_test(prev_sub_status, SUB_BIT_EXIST)) {			dev_info(&client->dev, "[%d][R] M[%d] Ver[%02x] Mode[%02x]\n",					i, info->move_cnt[i],					info->cap_info.reg_data_version, m_optional_mode);			info->move_cnt[i] = 0;			info->finger_cnt--;			if (info->finger_cnt == 0) {				input_report_key(info->input_dev, BTN_TOUCH, 0);			}			memset(&info->touch_info.coord[i], 0x0, sizeof(struct coord));			input_mt_slot(info->input_dev, i);			input_mt_report_slot_state(info->input_dev, MT_TOOL_FINGER, 0);		} else			memset(&info->touch_info.coord[i], 0x0, sizeof(struct coord));	}	memcpy((char *)&info->reported_touch_info, (char *)&info->touch_info,							sizeof(struct point_info));	input_sync(info->input_dev);out:#ifdef CONFIG_INPUT_BOOSTER	if (info->booster && info->booster->dvfs_set)		info->booster->dvfs_set(info->booster, info->finger_cnt > 0 ? 1 : 0);#endif	if (info->work_state == NORMAL) {#if ESD_TIMER_INTERVAL	//	esd_timer_start(CHECK_ESD_TIMER, info);#endif		info->work_state = NOTHING;	}	up(&info->work_lock);	return IRQ_HANDLED;}#if defined(CONFIG_PM)static int zt7548_ts_resume(struct device *dev){	struct i2c_client *client = to_i2c_client(dev);	struct zt7548_ts_info *info = i2c_get_clientdata(client);	if(info->device_enabled) {		dev_err(&client->dev, "%s: already enabled\n", __func__);		return 0;	}	down(&info->work_lock);	if (info->work_state != SUSPEND) {		dev_err(&client->dev, "%s: Invalid work proceedure\n", __func__);		up(&info->work_lock);		return 0;	}	zt7548_pinctrl_configure(info, 1);	zt7548_power_control(info, POWER_ON_SEQUENCE);	info->device_enabled = 1;	info->work_state = NOTHING;	if (!mini_init_touch(info))		dev_err(&client->dev, "Failed to resume\n");	enable_irq(info->irq);	up(&info->work_lock);	return 0;}static int zt7548_ts_suspend(struct device *dev){	struct i2c_client *client = to_i2c_client(dev);	struct zt7548_ts_info *info = i2c_get_clientdata(client);	if (!info->device_enabled) {		dev_err(&client->dev, "%s: already disabled\n", __func__);		return 0;	}	info->device_enabled = 0;	disable_irq(info->irq);#if ESD_TIMER_INTERVAL	flush_work(&info->tmr_work);#endif	down(&info->work_lock);	if (info->work_state != NOTHING && info->work_state != SUSPEND) {		dev_err(&client->dev, "%s: Invalid work proceedure\n", __func__);		up(&info->work_lock);		enable_irq(info->irq);		return 0;	}	clear_report_data(info);#if ESD_TIMER_INTERVAL	esd_timer_stop(info);#endif	write_cmd(info->client, ZT7548_SLEEP_CMD);	info->work_state = SUSPEND;	zt7548_power_control(info, POWER_OFF);	zt7548_pinctrl_configure(info, 0);	up(&info->work_lock);	return 0;}#endifstatic int zt7548_input_open(struct input_dev *dev){	struct zt7548_ts_info *info;	info = input_get_drvdata(dev);	dev_info(&info->client->dev, "%s\n", __func__);	return zt7548_ts_resume(&info->client->dev);}static void zt7548_input_close(struct input_dev *dev){	struct zt7548_ts_info *info;	info = input_get_drvdata(dev);	dev_info(&info->client->dev, "%s\n", __func__);	zt7548_ts_suspend(&info->client->dev);}/* For HFDND */#if defined(CONFIG_TOUCHSCREEN_ZT7548_TS)static bool ts_set_touchmode3(u16 value){	int i;	disable_irq(misc_info->irq);	down(&misc_info->work_lock);	if (misc_info->work_state != NOTHING) {		dev_info(&misc_info->client->dev, "other process occupied.. (%d)\n",			misc_info->work_state);		enable_irq(misc_info->irq);		up(&misc_info->work_lock);		return -1;	}	if (misc_info->touch_mode == TOUCH_POINT_MODE) {		/* factory data */		read_data(misc_info->client, ZT7548_MUTUAL_AMP_V_SEL, (u8 *)&misc_info->cap_info.mutual_amp_v_sel, 2);		read_data(misc_info->client, ZT75XX_SX_AMP_V_SEL, (u8 *)&misc_info->cap_info.sx_amp_v_sel, 2);		read_data(misc_info->client, ZT75XX_SX_SUB_V_SEL, (u8 *)&misc_info->cap_info.sx_sub_v_sel, 2);		read_data(misc_info->client, ZT75XX_SY_AMP_V_SEL, (u8 *)&misc_info->cap_info.sy_amp_v_sel, 2);		read_data(misc_info->client, ZT75XX_SY_SUB_V_SEL, (u8 *)&misc_info->cap_info.sy_sub_v_sel, 2);		read_data(misc_info->client, ZT7548_AFE_FREQUENCY, (u8 *)&misc_info->cap_info.afe_frequency, 2);		read_data(misc_info->client, ZT7548_DND_SHIFT_VALUE, (u8 *)&misc_info->cap_info.shift_value, 2);	}	misc_info->work_state = SET_MODE;	if(value == TOUCH_RXSHORT_MODE) {			if (write_reg(misc_info->client, ZT75XX_SY_AMP_V_SEL,							SEC_SY_AMP_V_SEL)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SY_AMP_V_SEL %d.\n", SEC_SY_AMP_V_SEL);			if (write_reg(misc_info->client, ZT75XX_SY_SUB_V_SEL,							SEC_SY_SUB_V_SEL)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SY_SUB_V_SEL %d.\n", SEC_SY_SUB_V_SEL);			if (write_reg(misc_info->client, ZT7548_DND_N_COUNT,							SEC_SHORT_N_COUNT)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SHORT_N_COUNT %d.\n", SEC_SHORT_N_COUNT);			if (write_reg(misc_info->client, ZT7548_DND_U_COUNT,							SEC_SHORT_U_COUNT)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SHORT_U_COUNT %d.\n", SEC_SHORT_U_COUNT);	}	else if(value == TOUCH_TXSHORT_MODE) {		if (write_reg(misc_info->client, ZT75XX_SX_AMP_V_SEL,							SEC_SX_AMP_V_SEL)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SX_AMP_V_SEL %d.\n", SEC_SX_AMP_V_SEL);			if (write_reg(misc_info->client, ZT75XX_SX_SUB_V_SEL,							SEC_SX_SUB_V_SEL)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SX_SUB_V_SEL %d.\n", SEC_SX_SUB_V_SEL);			if (write_reg(misc_info->client, ZT7548_DND_N_COUNT,							SEC_SHORT_N_COUNT)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SHORT_N_COUNT %d.\n", SEC_SHORT_N_COUNT);			if (write_reg(misc_info->client, ZT7548_DND_U_COUNT,							SEC_SHORT_U_COUNT)!=I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "						"Fail to set SEC_SHORT_U_COUNT %d.\n", SEC_SHORT_U_COUNT);	}	else if(misc_info->touch_mode == TOUCH_RXSHORT_MODE || misc_info->touch_mode == TOUCH_TXSHORT_MODE ) {			if (write_reg(misc_info->client, ZT7548_MUTUAL_AMP_V_SEL,							misc_info->cap_info.mutual_amp_v_sel) != I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "					"Fail to reset ZT7548_MUTUAL_AMP_V_SEL %d.\n",					misc_info->cap_info.mutual_amp_v_sel);			if (write_reg(misc_info->client, ZT75XX_SY_AMP_V_SEL,							misc_info->cap_info.sy_amp_v_sel) != I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "					"Fail to reset ZT75XX_SY_AMP_V_SEL %d.\n",					misc_info->cap_info.sy_amp_v_sel);			if (write_reg(misc_info->client, ZT75XX_SY_SUB_V_SEL,										misc_info->cap_info.sy_sub_v_sel) != I2C_SUCCESS)							dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "								"Fail to reset ZT75XX_SY_SUB_V_SEL %d.\n",								misc_info->cap_info.sy_sub_v_sel);			if (write_reg(misc_info->client, ZT75XX_SX_AMP_V_SEL,										misc_info->cap_info.sx_amp_v_sel) != I2C_SUCCESS)							dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "								"Fail to reset ZT75XX_SX_AMP_V_SEL %d.\n",								misc_info->cap_info.sx_amp_v_sel);			if (write_reg(misc_info->client, ZT75XX_SX_SUB_V_SEL,										misc_info->cap_info.sx_sub_v_sel) != I2C_SUCCESS)							dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "								"Fail to reset ZT75XX_SX_SUB_V_SEL %d.\n",								misc_info->cap_info.sx_sub_v_sel);			if (write_reg(misc_info->client, ZT7548_DND_SHIFT_VALUE,				misc_info->cap_info.shift_value) != I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "					"Fail to reset ZT7548_DND_SHIFT_VALUE %d.\n",					misc_info->cap_info.shift_value);			if (write_reg(misc_info->client, ZT7548_AFE_FREQUENCY,				misc_info->cap_info.afe_frequency) != I2C_SUCCESS)				dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "					"Fail to reset ZT7548_AFE_FREQUENCY %d.\n",					misc_info->cap_info.afe_frequency);	}	if (value == TOUCH_SEC_MODE)		misc_info->touch_mode = TOUCH_POINT_MODE;	else		misc_info->touch_mode = value;	dev_info(&misc_info->client->dev, "[zinitix_touch] tsp_set_testmode, "		"touchkey_testmode = %d\r\n", misc_info->touch_mode);	if (misc_info->touch_mode != TOUCH_POINT_MODE) {			if (write_reg(misc_info->client, ZT7548_DELAY_RAW_FOR_HOST,				RAWDATA_DELAY_FOR_HOST) != I2C_SUCCESS)				dev_info(&misc_info->client->dev, "Fail to set ZT7548_DELAY_RAW_FOR_HOST.\r\n");	}	if (write_reg(misc_info->client,ZT7548_TOUCH_MODE,				misc_info->touch_mode) != I2C_SUCCESS)			dev_info(&misc_info->client->dev, "[zinitix_touch] TEST Mode : "					"Fail to set ZINITX_TOUCH_MODE %d.\r\n", misc_info->touch_mode);	/* clear garbage data */	for (i = 0; i < 10; i++) {		zinitix_delay(20);		write_cmd(misc_info->client, ZT7548_CLEAR_INT_STATUS_CMD);	}	misc_info->work_state = NOTHING;	enable_irq(misc_info->irq);	up(&misc_info->work_lock);	return 1;}#endif#ifdef CONFIG_OFstatic const struct of_device_id tsp_dt_ids[] = {	{ .compatible = "Zinitix,zt7548_ts", },	{},};MODULE_DEVICE_TABLE(of, tsp_dt_ids);#else#define tsp_dt_ids NULL#endifstatic int zt7548_ts_parse_dt(struct device_node *np, struct device *dev,					struct zt7548_ts_dt_data *pdata){	int ret;	if (!np)		return -EINVAL;	pr_info("%s: ", __func__);	/* gpio irq */	pdata->gpio_int = of_get_named_gpio(np, "zinitix,irq-gpio", 0);	if (pdata->gpio_int < 0) {		dev_err(dev, "failed to get irq number\n");		return -EINVAL;	}	pr_cont("int:%d, ", pdata->gpio_int);	ret = gpio_request(pdata->gpio_int, "zt7548_irq");	if (ret < 0) {		dev_err(dev, "failed to request gpio_irq\n");		return -EINVAL;	}	gpio_direction_input(pdata->gpio_int);	/*pdata->gpio_scl = of_get_named_gpio(np, "zinitix,scl-gpio", 0);	if (pdata->gpio_scl < 0) {		dev_err(dev, "failed to get scl number\n");		return -EINVAL;	}	pr_cont("scl:%d, ", pdata->gpio_scl);	pdata->gpio_sda = of_get_named_gpio(np, "zinitix,sda-gpio", 0);	if (pdata->gpio_sda < 0) {		dev_err(dev, "failed to get sda number\n");		return -EINVAL;	}	pr_cont("sda:%d, ", pdata->gpio_sda);	 gpio power enable 	pdata->vdd_en = of_get_named_gpio(np, "zinitix,tsppwr_en", 0);	if (pdata->vdd_en < 0) {		pr_info("%s: ", __func__);	}	pr_cont("vdd_en:%d, ", pdata->vdd_en);	if (gpio_is_valid(pdata->vdd_en)) {		ret = gpio_request(pdata->vdd_en, "zt7548_vdd_en");		if (ret < 0) {			dev_err(dev, "failed to request gpio_vdd_en\n");			return -EINVAL;		}	}	ret = of_property_read_string(np, "zt7548,fw_name", &pdata->fw_name);	if (ret < 0) {		dev_err(dev, "failed to get firmware path!\n");		return -EINVAL;	}	pr_cont("fw_name:%s, ", pdata->fw_name);    */	ret = of_property_read_u32(np, "zt7548,x_resolution", &pdata->x_resolution);	if (ret < 0) {		dev_err(dev, "failed to get x_resolution\n");		return ret;	}	printk("max_x:%d, ", pdata->x_resolution);	ret = of_property_read_u32(np, "zt7548,y_resolution", &pdata->y_resolution);	if (ret < 0) {		dev_err(dev, "failed to get y_resolution\n");		return ret;	}	pr_cont("max_y:%d, ", pdata->y_resolution);	ret = of_property_read_string(np, "zt7548,model_name", &pdata->model_name);	if (ret < 0) {		pdata->model_name = "";	}	pr_cont("model:%s, ", pdata->model_name);	pdata->reg_boot_on = 0;	pdata->tsp_power = zt7548_power;	pr_cont("end\n");	return 0;}#if ZINITIX_MISC_DEBUGstatic int ts_misc_fops_open(struct inode *inode, struct file *filp){	return 0;}static int ts_misc_fops_close(struct inode *inode, struct file *filp){	return 0;}static long ts_misc_fops_ioctl(struct file *filp,	unsigned int cmd, unsigned long arg){	void __user *argp = (void __user *)arg;	struct raw_ioctl raw_ioctl;	u8 *u8Data;	int ret = 0;	size_t sz = 0;//	u16 version;	u16 mode;	struct reg_ioctl reg_ioctl;	u16 val;	int nval = 0;	if (!misc_info) {		dev_err(&misc_info->client->dev, "misc device NULL?\n");		return -1;	}	switch (cmd) {	case TOUCH_IOCTL_GET_DEBUGMSG_STATE:		ret = m_ts_debug_mode;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_SET_DEBUGMSG_STATE:		if (copy_from_user(&nval, argp, 4)) {			dev_err(&misc_info->client->dev, "error : copy_from_user\n");			return -1;		}		if (nval)			dev_err(&misc_info->client->dev, "on debug mode (%d)\n", nval);		else			dev_err(&misc_info->client->dev, "off debug mode (%d)\n", nval);		m_ts_debug_mode = nval;		break;	case TOUCH_IOCTL_GET_CHIP_REVISION:		ret = misc_info->cap_info.ic_revision;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_GET_FW_VERSION:		ret = misc_info->cap_info.fw_version;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_GET_REG_DATA_VERSION:		ret = misc_info->cap_info.reg_data_version;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_VARIFY_UPGRADE_SIZE:		if (copy_from_user(&sz, argp, sizeof(size_t)))			return -1;		dev_info(&misc_info->client->dev, "firmware size = %ld\n", sz);		if (misc_info->cap_info.ic_fw_size != sz) {			dev_err(&misc_info->client->dev, ": firmware size error\r\n");			return -1;		}		break;/*	case TOUCH_IOCTL_VARIFY_UPGRADE_DATA:		if (copy_from_user(m_firmware_data,			argp, misc_info->cap_info.ic_fw_size))			return -1;		version = (u16) (m_firmware_data[52] | (m_firmware_data[53]<<8));		dev_err(&misc_info->client->dev, "firmware version = %x\n", version);		if (copy_to_user(argp, &version, sizeof(version)))			return -1;		break;	case TOUCH_IOCTL_START_UPGRADE:		return ts_upgrade_sequence((u8 *)m_firmware_data);*/	case TOUCH_IOCTL_GET_X_RESOLUTION:		ret = misc_info->pdata->x_resolution;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_GET_Y_RESOLUTION:		ret = misc_info->pdata->y_resolution;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_GET_X_NODE_NUM:		ret = misc_info->cap_info.x_node_num;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_GET_Y_NODE_NUM:		ret = misc_info->cap_info.y_node_num;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_GET_TOTAL_NODE_NUM:		ret = misc_info->cap_info.total_node_num;		if (copy_to_user(argp, &ret, sizeof(ret)))			return -1;		break;	case TOUCH_IOCTL_HW_CALIBRAION:		ret = -1;		disable_irq(misc_info->irq);		down(&misc_info->work_lock);		if (misc_info->work_state != NOTHING) {			dev_err(&misc_info->client->dev, ": other process occupied.. (%d)\n",				misc_info->work_state);			up(&misc_info->work_lock);			return -1;		}		misc_info->work_state = HW_CALIBRAION;		zinitix_delay(100);		/* h/w calibration */		if (ts_hw_calibration(misc_info))			ret = 0;		mode = misc_info->touch_mode;		if (write_reg(misc_info->client,			ZT7548_TOUCH_MODE, mode) != I2C_SUCCESS) {			dev_err(&misc_info->client->dev, "failed to set touch mode %d.\n", mode);			goto fail_hw_cal;		}		if (write_cmd(misc_info->client, ZT7548_SWRESET_CMD) != I2C_SUCCESS)			goto fail_hw_cal;		enable_irq(misc_info->irq);		misc_info->work_state = NOTHING;		up(&misc_info->work_lock);		return ret;fail_hw_cal:		enable_irq(misc_info->irq);		misc_info->work_state = NOTHING;		up(&misc_info->work_lock);		return -1;	case TOUCH_IOCTL_SET_RAW_DATA_MODE:		if (misc_info == NULL) {			dev_err(&misc_info->client->dev, "misc device NULL?\n");			return -1;		}		if (copy_from_user(&nval, argp, 4)) {			dev_err(&misc_info->client->dev, " error : copy_from_user\r\n");			misc_info->work_state = NOTHING;			return -1;		}		ts_set_touchmode((u16)nval);		return 0;	case TOUCH_IOCTL_GET_REG:		if (misc_info == NULL) {			dev_err(&misc_info->client->dev, "misc device NULL?\n");			return -1;		}		down(&misc_info->work_lock);		if (misc_info->work_state != NOTHING) {			dev_err(&misc_info->client->dev, ":other process occupied.. (%d)\n",				misc_info->work_state);			up(&misc_info->work_lock);			return -1;		}		misc_info->work_state = SET_MODE;		if (copy_from_user(&reg_ioctl,			argp, sizeof(struct reg_ioctl))) {			misc_info->work_state = NOTHING;			up(&misc_info->work_lock);			dev_err(&misc_info->client->dev, " error : copy_from_user(1)\n");			return -1;		}		if (read_data(misc_info->client,			(u16)reg_ioctl.addr, (u8 *)&val, 2) < 0)			ret = -1;		nval = (int)val;		if (copy_to_user((void *)reg_ioctl.val, (u8 *)&nval, 4)) {			misc_info->work_state = NOTHING;			up(&misc_info->work_lock);			dev_err(&misc_info->client->dev, " error : copy_to_user(2)\n");			return -1;		}		dev_err(&misc_info->client->dev, "read : reg addr = 0x%x, val = 0x%x\n",			reg_ioctl.addr, nval);		misc_info->work_state = NOTHING;		up(&misc_info->work_lock);		return ret;	case TOUCH_IOCTL_SET_REG:		down(&misc_info->work_lock);		if (misc_info->work_state != NOTHING) {			dev_err(&misc_info->client->dev, ": other process occupied.. (%d)\n",				misc_info->work_state);			up(&misc_info->work_lock);			return -1;		}		misc_info->work_state = SET_MODE;		if (copy_from_user(&reg_ioctl,				argp, sizeof(struct reg_ioctl))) {			misc_info->work_state = NOTHING;			up(&misc_info->work_lock);			dev_err(&misc_info->client->dev, " error : copy_from_user(1)\n");			return -1;		}		if (copy_from_user(&val, (void *)reg_ioctl.val, 4)) {			misc_info->work_state = NOTHING;			up(&misc_info->work_lock);			dev_err(&misc_info->client->dev, " error : copy_from_user(2)\n");			return -1;		}		if (write_reg(misc_info->client,			(u16)reg_ioctl.addr, val) != I2C_SUCCESS)			ret = -1;		dev_err(&misc_info->client->dev, "write : reg addr = 0x%x, val = 0x%x\r\n",			reg_ioctl.addr, val);		misc_info->work_state = NOTHING;		up(&misc_info->work_lock);		return ret;	case TOUCH_IOCTL_DONOT_TOUCH_EVENT:		if (misc_info == NULL) {			dev_err(&misc_info->client->dev, "misc device NULL?\n");			return -1;		}		down(&misc_info->work_lock);		if (misc_info->work_state != NOTHING) {			dev_err(&misc_info->client->dev, ": other process occupied.. (%d)\r\n",				misc_info->work_state);			up(&misc_info->work_lock);			return -1;		}		misc_info->work_state = SET_MODE;		if (write_reg(misc_info->client,			ZT7548_INT_ENABLE_FLAG, 0) != I2C_SUCCESS)			ret = -1;		dev_err(&misc_info->client->dev, "write : reg addr = 0x%x, val = 0x0\r\n",			ZT7548_INT_ENABLE_FLAG);		misc_info->work_state = NOTHING;		up(&misc_info->work_lock);		return ret;	case TOUCH_IOCTL_SEND_SAVE_STATUS:		if (misc_info == NULL) {			dev_err(&misc_info->client->dev, "misc device NULL?\n");			return -1;		}		down(&misc_info->work_lock);		if (misc_info->work_state != NOTHING) {			dev_err(&misc_info->client->dev, ": other process occupied.." \				"(%d)\r\n", misc_info->work_state);			up(&misc_info->work_lock);			return -1;		}		misc_info->work_state = SET_MODE;		ret = 0;		if (write_cmd(misc_info->client,			ZT7548_SAVE_STATUS_CMD) != I2C_SUCCESS)			ret =  -1;		zinitix_delay(1000);	/* for fusing eeprom */		misc_info->work_state = NOTHING;		up(&misc_info->work_lock);		return ret;	case TOUCH_IOCTL_GET_RAW_DATA:		if (misc_info == NULL) {			dev_err(&misc_info->client->dev, "misc device NULL?\n");			return -1;		}		if (misc_info->touch_mode == TOUCH_POINT_MODE)			return -1;		down(&misc_info->raw_data_lock);		if (misc_info->update == 0) {			up(&misc_info->raw_data_lock);			return -2;		}		if (copy_from_user(&raw_ioctl,			argp, sizeof(struct raw_ioctl))) {			up(&misc_info->raw_data_lock);			dev_err(&misc_info->client->dev, "error: copy_from_user\r\n");			return -1;		}		misc_info->update = 0;		u8Data = (u8 *)&misc_info->cur_data[0];		if (raw_ioctl.sz > MAX_TRAW_DATA_SZ * 2)			raw_ioctl.sz = MAX_TRAW_DATA_SZ * 2;//(u8 *)		if (copy_to_user((void *)raw_ioctl.buf, (u8 *)u8Data, (unsigned long)raw_ioctl.sz)) {			up(&misc_info->raw_data_lock);			return -1;		}		up(&misc_info->raw_data_lock);		return 0;	default:		break;	}	return 0;}static const struct file_operations ts_misc_fops = {	.owner = THIS_MODULE,	.open = ts_misc_fops_open,	.release = ts_misc_fops_close,	.unlocked_ioctl = ts_misc_fops_ioctl,};static struct miscdevice touch_misc_device = {	.minor = MISC_DYNAMIC_MINOR,	.name = "zinitix_touch_misc",	.fops = &ts_misc_fops,};#endifstatic int zt7548_pinctrl_configure(struct zt7548_ts_info *info,							bool active){	struct pinctrl_state *irq;	int retval;	dev_err(&info->client->dev, "%s: %s\n", __func__, active ? "ACTIVE" : "SUSPEND");	irq =		pinctrl_lookup_state(info->pinctrl,					PINCTRL_STATE_DEFAULT);	if (IS_ERR(irq)) {		dev_err(&info->client->dev, "%s: cannot get pinctrl(i2c) active state\n", __func__);		return PTR_ERR(irq);	}	retval = pinctrl_select_state(info->pinctrl, irq);	if (retval) {		dev_err(&info->client->dev, "%s: cannot set pinctrl(i2c) %s state\n",				__func__, active ? "active" : "suspend");		return retval;	}	return 0;}static int zt7548_ts_probe(struct i2c_client *client, const struct i2c_device_id *i2c_id){	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);	struct zt7548_ts_dt_data *pdata = client->dev.platform_data;	struct zt7548_ts_info *info;	struct input_dev *input_dev;	int ret = -1;	int i;	struct device_node *np = client->dev.of_node;	if (IS_ENABLED(CONFIG_OF)) {		if (!pdata) {			pdata = devm_kzalloc(&client->dev,					sizeof(*pdata), GFP_KERNEL);			if (!pdata)				return -ENOMEM;		}		ret = zt7548_ts_parse_dt(np, &client->dev, pdata);		if (ret)			goto err_no_platform_data;	} else if (!pdata) {		dev_err(&client->dev, "Not exist platform data\n");		return -EINVAL;	}	if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {		dev_err(&client->dev, "Not compatible i2c function\n");		ret = -EIO;		goto err_no_platform_data;	}	info = devm_kzalloc(&client->dev, sizeof(struct zt7548_ts_info), GFP_KERNEL);	if (!info) {		dev_err(&client->dev, "Failed to allocate memory\n");		ret = -ENOMEM;		goto err_no_platform_data;	}	i2c_set_clientdata(client, info);	info->client = client;	info->pdata = pdata;	info->device_enabled = 1;	input_dev = input_allocate_device();	if (!input_dev) {		dev_err(&client->dev, "Failed to allocate input device\n");		ret = -ENOMEM;		goto err_alloc;	}	info->input_dev = input_dev;	info->work_state = PROBE;	/* Get pinctrl if target uses pinctrl */	info->pinctrl = devm_pinctrl_get(&client->dev);	if (IS_ERR(info->pinctrl)) {		if (PTR_ERR(info->pinctrl) == -EPROBE_DEFER) {			ret = -ENODEV;			goto err_alloc;	// err_input_alloc;		}		dev_err(&client->dev, "%s: Target does not use pinctrl\n", __func__);		info->pinctrl = NULL;	}	if (info->pinctrl) {		ret = zt7548_pinctrl_configure(info, true);		if (ret)			dev_err(&client->dev, "%s: cannot set pinctrl state\n", __func__);	}	/* power on */	if (!zt7548_power_control(info, POWER_ON_SEQUENCE)) {		ret = -EPERM;		goto err_power_sequence;	}	memset(&info->reported_touch_info, 0x0, sizeof(struct point_info));	sema_init(&info->work_lock, 1);	/* init touch mode */	info->touch_mode = TOUCH_POINT_MODE;	misc_info = info;	if (!init_touch(info, false)) {		ret = -EPERM;		goto err_input_unregister_device;	}	for (i = 0; i < MAX_SUPPORTED_BUTTON_NUM; i++)		info->button[i] = ICON_BUTTON_UNCHANGE;#ifdef USE_TSP_TA_CALLBACKS	info->pdata->callbacks.inform_charger = zt7548_ts_charger_status_cb;	zt7548_register_callback(&info->pdata->callbacks);#endif	snprintf(info->phys, sizeof(info->phys), "%s/input0", dev_name(&client->dev));	input_dev->name = "sec_touchscreen";	input_dev->id.bustype = BUS_I2C;	input_dev->phys = info->phys;	input_dev->dev.parent = &client->dev;	set_bit(EV_SYN, info->input_dev->evbit);	set_bit(EV_KEY, info->input_dev->evbit);	set_bit(EV_ABS, info->input_dev->evbit);	set_bit(BTN_TOUCH, info->input_dev->keybit);	set_bit(INPUT_PROP_DIRECT, info->input_dev->propbit);	for (i = 0; i < MAX_SUPPORTED_BUTTON_NUM; i++)		set_bit(BUTTON_MAPPING_KEY[i], info->input_dev->keybit);	if (pdata->orientation & TOUCH_XY_SWAP) {		input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y,			info->cap_info.MinX, info->cap_info.MaxX + ABS_PT_OFFSET, 0, 0);		input_set_abs_params(info->input_dev, ABS_MT_POSITION_X,			info->cap_info.MinY, info->cap_info.MaxY + ABS_PT_OFFSET, 0, 0);	} else {		input_set_abs_params(info->input_dev, ABS_MT_POSITION_X,			info->cap_info.MinX, info->cap_info.MaxX + ABS_PT_OFFSET, 0, 0);		input_set_abs_params(info->input_dev, ABS_MT_POSITION_Y,			info->cap_info.MinY, info->cap_info.MaxY + ABS_PT_OFFSET, 0, 0);	}	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);	input_set_abs_params(info->input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);#if SUPPORTED_PALM_TOUCH	input_set_abs_params(info->input_dev, ABS_MT_TOUCH_MINOR,			0, 255, 0, 0);	input_set_abs_params(info->input_dev, ABS_MT_CUSTOM,				0, 1, 0, 0);#endif#ifdef REPORT_2D_Z	input_set_abs_params(info->input_dev, ABS_MT_PRESSURE,			0, REAL_Z_MAX, 0, 0);#endif	set_bit(MT_TOOL_FINGER, info->input_dev->keybit);	input_mt_init_slots(info->input_dev, info->cap_info.multi_fingers, 0);	info->input_dev->open = zt7548_input_open;	info->input_dev->close = zt7548_input_close;	input_set_drvdata(info->input_dev, info);	ret = input_register_device(info->input_dev);	if (ret) {		dev_err(&info->client->dev, "unable to register input device\n");		goto err_input_register_device;	}	info->work_state = NOTHING;	info->finger_cnt = 0;#if ESD_TIMER_INTERVAL	spin_lock_init(&info->lock);	INIT_WORK(&info->tmr_work, ts_tmr_work);	esd_tmr_workqueue =		create_singlethread_workqueue("esd_tmr_workqueue");	if (!esd_tmr_workqueue) {		dev_err(&client->dev, "Failed to create esd tmr work queue\n");		ret = -EPERM;		goto err_esd_input_unregister_device;	}	esd_timer_init(info);	esd_timer_start(CHECK_ESD_TIMER, info);#endif#ifdef CONFIG_INPUT_BOOSTER	info->booster = input_booster_allocate(INPUT_BOOSTER_ID_TSP);	if (!info->booster) {		dev_err(&client->dev, "%s: Error, failed to allocate input booster\n",__func__);		ret = -ENODEV;		goto error_alloc_booster_failed;	}#endif	info->irq = gpio_to_irq(pdata->gpio_int);	if (info->irq < 0) {		dev_err(&client->dev, "failed to get gpio_to_irq\n");		ret = -ENODEV;		goto err_gpio_irq;	}	ret = request_threaded_irq(info->irq, NULL, zt7548_touch_work,		IRQF_TRIGGER_FALLING | IRQF_ONESHOT , ZT7548_TS_DEVICE, info);	if (ret) {		dev_err(&client->dev, "failed to request irq.\n");		goto err_request_irq;	}#if defined(CONFIG_PM_RUNTIME)	pm_runtime_enable(&client->dev);#endif	sema_init(&info->raw_data_lock, 1);#if ZINITIX_MISC_DEBUG	ret = misc_register(&touch_misc_device);	if (ret) {		dev_err(&client->dev, "Failed to register touch misc device\n");		goto err_misc_register;	}#endif	dev_info(&client->dev, "zinitix touch probe done.\n");	return 0;#if ZINITIX_MISC_DEBUGerr_misc_register:#endif	free_irq(info->irq, info);err_request_irq:err_gpio_irq:#ifdef CONFIG_INPUT_BOOSTER	input_booster_free(info->booster);	info->booster = NULL;error_alloc_booster_failed:#endif#if ESD_TIMER_INTERVALerr_esd_input_unregister_device:#endif	input_unregister_device(info->input_dev);err_input_unregister_device:err_input_register_device:#ifdef USE_TSP_TA_CALLBACKS	zt7548_register_callback(NULL);#endif	zt7548_power_control(info, POWER_OFF);err_power_sequence:	input_free_device(info->input_dev);err_alloc:	devm_kfree(&client->dev, info);err_no_platform_data:	if (IS_ENABLED(CONFIG_OF))		devm_kfree(&client->dev, (void *)pdata);	dev_info(&client->dev, "Failed to probe\n");	return ret;}static int zt7548_ts_remove(struct i2c_client *client){	struct zt7548_ts_info *info = i2c_get_clientdata(client);	struct zt7548_ts_dt_data *pdata = info->pdata;	disable_irq(info->irq);	down(&info->work_lock);	info->work_state = REMOVE;#if ESD_TIMER_INTERVAL	flush_work(&info->tmr_work);	write_reg(info->client, ZT7548_PERIODICAL_INTERRUPT_INTERVAL, 0);	esd_timer_stop(info);	destroy_workqueue(esd_tmr_workqueue);#endif	if (info->irq)		free_irq(info->irq, info);#if ZINITIX_MISC_DEBUG	misc_deregister(&touch_misc_device);#endif	if (gpio_is_valid(pdata->gpio_int) != 0)		gpio_free(pdata->gpio_int);	input_unregister_device(info->input_dev);	input_free_device(info->input_dev);	up(&info->work_lock);	devm_kfree(&client->dev, info);	return 0;}void zt7548_ts_shutdown(struct i2c_client *client){	struct zt7548_ts_info *info = i2c_get_clientdata(client);	disable_irq(info->irq);	down(&info->work_lock);#if ESD_TIMER_INTERVAL	flush_work(&info->tmr_work);	esd_timer_stop(info);#endif	up(&info->work_lock);	zt7548_power_control(info, POWER_OFF);}static struct i2c_device_id zt7548_idtable[] = {	{ZT7548_TS_DEVICE, 0},	{ }};static struct i2c_driver zt7548_ts_driver = {	.probe	= zt7548_ts_probe,	.remove	= zt7548_ts_remove,	.shutdown = zt7548_ts_shutdown,	.id_table	= zt7548_idtable,	.driver		= {		.owner	= THIS_MODULE,		.name	= ZT7548_TS_DEVICE,		.of_match_table = tsp_dt_ids,	},};#define CONFIG_SAMSUNG_LPM_MODE 0#ifdef CONFIG_SAMSUNG_LPM_MODEextern int poweroff_charging;#endifstatic int __init zt7548_ts_init(void){	return i2c_add_driver(&zt7548_ts_driver);}static void __exit zt7548_ts_exit(void){	i2c_del_driver(&zt7548_ts_driver);}module_init(zt7548_ts_init);module_exit(zt7548_ts_exit);MODULE_DESCRIPTION("touch-screen device driver using i2c interface");MODULE_AUTHOR("<mika.kim@samsung.com>");MODULE_LICENSE("GPL");